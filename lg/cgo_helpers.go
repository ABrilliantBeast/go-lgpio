// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 13 Aug 2025 17:09:29 BST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package lg

/*
#cgo LDFLAGS: -llgpio
#include <lgpio.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocLgChipInfoMemory allocates memory for type C.lgChipInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgChipInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgChipInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgChipInfoValue = unsafe.Sizeof([1]C.lgChipInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgChipInfo) Ref() *C.lgChipInfo_t {
	if x == nil {
		return nil
	}
	return x.refa740d20d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgChipInfo) Free() {
	if x != nil && x.allocsa740d20d != nil {
		x.allocsa740d20d.(*cgoAllocMap).Free()
		x.refa740d20d = nil
	}
}

// NewLgChipInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgChipInfoRef(ref unsafe.Pointer) *LgChipInfo {
	if ref == nil {
		return nil
	}
	obj := new(LgChipInfo)
	obj.refa740d20d = (*C.lgChipInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgChipInfo) PassRef() (*C.lgChipInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa740d20d != nil {
		return x.refa740d20d, nil
	}
	mema740d20d := allocLgChipInfoMemory(1)
	refa740d20d := (*C.lgChipInfo_t)(mema740d20d)
	allocsa740d20d := new(cgoAllocMap)
	allocsa740d20d.Add(mema740d20d)

	var clines_allocs *cgoAllocMap
	refa740d20d.lines, clines_allocs = (C.uint32_t)(x.Lines), cgoAllocsUnknown
	allocsa740d20d.Borrow(clines_allocs)

	var cname_allocs *cgoAllocMap
	refa740d20d.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocsa740d20d.Borrow(cname_allocs)

	var clabel_allocs *cgoAllocMap
	refa740d20d.label, clabel_allocs = *(*[32]C.char)(unsafe.Pointer(&x.Label)), cgoAllocsUnknown
	allocsa740d20d.Borrow(clabel_allocs)

	x.refa740d20d = refa740d20d
	x.allocsa740d20d = allocsa740d20d
	return refa740d20d, allocsa740d20d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgChipInfo) PassValue() (C.lgChipInfo_t, *cgoAllocMap) {
	if x.refa740d20d != nil {
		return *x.refa740d20d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgChipInfo) Deref() {
	if x.refa740d20d == nil {
		return
	}
	x.Lines = (uint32)(x.refa740d20d.lines)
	x.Name = *(*[32]byte)(unsafe.Pointer(&x.refa740d20d.name))
	x.Label = *(*[32]byte)(unsafe.Pointer(&x.refa740d20d.label))
}

// allocLgNotifyMemory allocates memory for type C.lgNotify_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgNotifyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgNotifyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgNotifyValue = unsafe.Sizeof([1]C.lgNotify_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgNotify) Ref() *C.lgNotify_t {
	if x == nil {
		return nil
	}
	return x.ref7a0dd963
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgNotify) Free() {
	if x != nil && x.allocs7a0dd963 != nil {
		x.allocs7a0dd963.(*cgoAllocMap).Free()
		x.ref7a0dd963 = nil
	}
}

// NewLgNotifyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgNotifyRef(ref unsafe.Pointer) *LgNotify {
	if ref == nil {
		return nil
	}
	obj := new(LgNotify)
	obj.ref7a0dd963 = (*C.lgNotify_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgNotify) PassRef() (*C.lgNotify_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a0dd963 != nil {
		return x.ref7a0dd963, nil
	}
	mem7a0dd963 := allocLgNotifyMemory(1)
	ref7a0dd963 := (*C.lgNotify_t)(mem7a0dd963)
	allocs7a0dd963 := new(cgoAllocMap)
	allocs7a0dd963.Add(mem7a0dd963)

	var cstate_allocs *cgoAllocMap
	ref7a0dd963.state, cstate_allocs = (C.uint16_t)(x.State), cgoAllocsUnknown
	allocs7a0dd963.Borrow(cstate_allocs)

	var cfd_allocs *cgoAllocMap
	ref7a0dd963.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs7a0dd963.Borrow(cfd_allocs)

	var cpipe_number_allocs *cgoAllocMap
	ref7a0dd963.pipe_number, cpipe_number_allocs = (C.int)(x.Pipe_number), cgoAllocsUnknown
	allocs7a0dd963.Borrow(cpipe_number_allocs)

	var cmax_emits_allocs *cgoAllocMap
	ref7a0dd963.max_emits, cmax_emits_allocs = (C.int)(x.Max_emits), cgoAllocsUnknown
	allocs7a0dd963.Borrow(cmax_emits_allocs)

	x.ref7a0dd963 = ref7a0dd963
	x.allocs7a0dd963 = allocs7a0dd963
	return ref7a0dd963, allocs7a0dd963

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgNotify) PassValue() (C.lgNotify_t, *cgoAllocMap) {
	if x.ref7a0dd963 != nil {
		return *x.ref7a0dd963, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgNotify) Deref() {
	if x.ref7a0dd963 == nil {
		return
	}
	x.State = (uint16)(x.ref7a0dd963.state)
	x.Fd = (int32)(x.ref7a0dd963.fd)
	x.Pipe_number = (int32)(x.ref7a0dd963.pipe_number)
	x.Max_emits = (int32)(x.ref7a0dd963.max_emits)
}

// allocLgGpioReportMemory allocates memory for type C.lgGpioReport_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgGpioReportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgGpioReportValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgGpioReportValue = unsafe.Sizeof([1]C.lgGpioReport_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgGpioReport) Ref() *C.lgGpioReport_t {
	if x == nil {
		return nil
	}
	return x.ref36aaf007
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgGpioReport) Free() {
	if x != nil && x.allocs36aaf007 != nil {
		x.allocs36aaf007.(*cgoAllocMap).Free()
		x.ref36aaf007 = nil
	}
}

// NewLgGpioReportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgGpioReportRef(ref unsafe.Pointer) *LgGpioReport {
	if ref == nil {
		return nil
	}
	obj := new(LgGpioReport)
	obj.ref36aaf007 = (*C.lgGpioReport_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgGpioReport) PassRef() (*C.lgGpioReport_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref36aaf007 != nil {
		return x.ref36aaf007, nil
	}
	mem36aaf007 := allocLgGpioReportMemory(1)
	ref36aaf007 := (*C.lgGpioReport_t)(mem36aaf007)
	allocs36aaf007 := new(cgoAllocMap)
	allocs36aaf007.Add(mem36aaf007)

	var ctimestamp_allocs *cgoAllocMap
	ref36aaf007.timestamp, ctimestamp_allocs = (C.uint64_t)(x.Timestamp), cgoAllocsUnknown
	allocs36aaf007.Borrow(ctimestamp_allocs)

	var cchip_allocs *cgoAllocMap
	ref36aaf007.chip, cchip_allocs = (C.uint8_t)(x.Chip), cgoAllocsUnknown
	allocs36aaf007.Borrow(cchip_allocs)

	var cgpio_allocs *cgoAllocMap
	ref36aaf007.gpio, cgpio_allocs = (C.uint8_t)(x.Gpio), cgoAllocsUnknown
	allocs36aaf007.Borrow(cgpio_allocs)

	var clevel_allocs *cgoAllocMap
	ref36aaf007.level, clevel_allocs = (C.uint8_t)(x.Level), cgoAllocsUnknown
	allocs36aaf007.Borrow(clevel_allocs)

	var cflags_allocs *cgoAllocMap
	ref36aaf007.flags, cflags_allocs = (C.uint8_t)(x.Flags), cgoAllocsUnknown
	allocs36aaf007.Borrow(cflags_allocs)

	x.ref36aaf007 = ref36aaf007
	x.allocs36aaf007 = allocs36aaf007
	return ref36aaf007, allocs36aaf007

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgGpioReport) PassValue() (C.lgGpioReport_t, *cgoAllocMap) {
	if x.ref36aaf007 != nil {
		return *x.ref36aaf007, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgGpioReport) Deref() {
	if x.ref36aaf007 == nil {
		return
	}
	x.Timestamp = (uint64)(x.ref36aaf007.timestamp)
	x.Chip = (byte)(x.ref36aaf007.chip)
	x.Gpio = (byte)(x.ref36aaf007.gpio)
	x.Level = (byte)(x.ref36aaf007.level)
	x.Flags = (byte)(x.ref36aaf007.flags)
}

// allocLgLineInfoMemory allocates memory for type C.lgLineInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgLineInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgLineInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgLineInfoValue = unsafe.Sizeof([1]C.lgLineInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgLineInfo) Ref() *C.lgLineInfo_t {
	if x == nil {
		return nil
	}
	return x.ref7e1327b3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgLineInfo) Free() {
	if x != nil && x.allocs7e1327b3 != nil {
		x.allocs7e1327b3.(*cgoAllocMap).Free()
		x.ref7e1327b3 = nil
	}
}

// NewLgLineInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgLineInfoRef(ref unsafe.Pointer) *LgLineInfo {
	if ref == nil {
		return nil
	}
	obj := new(LgLineInfo)
	obj.ref7e1327b3 = (*C.lgLineInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgLineInfo) PassRef() (*C.lgLineInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7e1327b3 != nil {
		return x.ref7e1327b3, nil
	}
	mem7e1327b3 := allocLgLineInfoMemory(1)
	ref7e1327b3 := (*C.lgLineInfo_t)(mem7e1327b3)
	allocs7e1327b3 := new(cgoAllocMap)
	allocs7e1327b3.Add(mem7e1327b3)

	var coffset_allocs *cgoAllocMap
	ref7e1327b3.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs7e1327b3.Borrow(coffset_allocs)

	var clFlags_allocs *cgoAllocMap
	ref7e1327b3.lFlags, clFlags_allocs = (C.uint32_t)(x.LFlags), cgoAllocsUnknown
	allocs7e1327b3.Borrow(clFlags_allocs)

	var cname_allocs *cgoAllocMap
	ref7e1327b3.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs7e1327b3.Borrow(cname_allocs)

	var cuser_allocs *cgoAllocMap
	ref7e1327b3.user, cuser_allocs = *(*[32]C.char)(unsafe.Pointer(&x.User)), cgoAllocsUnknown
	allocs7e1327b3.Borrow(cuser_allocs)

	x.ref7e1327b3 = ref7e1327b3
	x.allocs7e1327b3 = allocs7e1327b3
	return ref7e1327b3, allocs7e1327b3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgLineInfo) PassValue() (C.lgLineInfo_t, *cgoAllocMap) {
	if x.ref7e1327b3 != nil {
		return *x.ref7e1327b3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgLineInfo) Deref() {
	if x.ref7e1327b3 == nil {
		return
	}
	x.Offset = (uint32)(x.ref7e1327b3.offset)
	x.LFlags = (uint32)(x.ref7e1327b3.lFlags)
	x.Name = *(*[32]byte)(unsafe.Pointer(&x.ref7e1327b3.name))
	x.User = *(*[32]byte)(unsafe.Pointer(&x.ref7e1327b3.user))
}

// allocLgPulseMemory allocates memory for type C.lgPulse_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgPulseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgPulseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgPulseValue = unsafe.Sizeof([1]C.lgPulse_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgPulse) Ref() *C.lgPulse_t {
	if x == nil {
		return nil
	}
	return x.refff55d232
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgPulse) Free() {
	if x != nil && x.allocsff55d232 != nil {
		x.allocsff55d232.(*cgoAllocMap).Free()
		x.refff55d232 = nil
	}
}

// NewLgPulseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgPulseRef(ref unsafe.Pointer) *LgPulse {
	if ref == nil {
		return nil
	}
	obj := new(LgPulse)
	obj.refff55d232 = (*C.lgPulse_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgPulse) PassRef() (*C.lgPulse_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff55d232 != nil {
		return x.refff55d232, nil
	}
	memff55d232 := allocLgPulseMemory(1)
	refff55d232 := (*C.lgPulse_t)(memff55d232)
	allocsff55d232 := new(cgoAllocMap)
	allocsff55d232.Add(memff55d232)

	var cbits_allocs *cgoAllocMap
	refff55d232.bits, cbits_allocs = (C.uint64_t)(x.Bits), cgoAllocsUnknown
	allocsff55d232.Borrow(cbits_allocs)

	var cmask_allocs *cgoAllocMap
	refff55d232.mask, cmask_allocs = (C.uint64_t)(x.Mask), cgoAllocsUnknown
	allocsff55d232.Borrow(cmask_allocs)

	var cdelay_allocs *cgoAllocMap
	refff55d232.delay, cdelay_allocs = (C.int64_t)(x.Delay), cgoAllocsUnknown
	allocsff55d232.Borrow(cdelay_allocs)

	x.refff55d232 = refff55d232
	x.allocsff55d232 = allocsff55d232
	return refff55d232, allocsff55d232

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgPulse) PassValue() (C.lgPulse_t, *cgoAllocMap) {
	if x.refff55d232 != nil {
		return *x.refff55d232, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgPulse) Deref() {
	if x.refff55d232 == nil {
		return
	}
	x.Bits = (uint64)(x.refff55d232.bits)
	x.Mask = (uint64)(x.refff55d232.mask)
	x.Delay = (int64)(x.refff55d232.delay)
}

// allocLgI2cMsgMemory allocates memory for type C.lgI2cMsg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLgI2cMsgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLgI2cMsgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLgI2cMsgValue = unsafe.Sizeof([1]C.lgI2cMsg_t{})

// copyPUint8Bytes copies the data from Go slice as *C.uint8_t.
func copyPUint8Bytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8Value) * slice.Len,
		Cap:  int(sizeOfUint8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocUint8Memory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8Value = unsafe.Sizeof([1]C.uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LgI2cMsg) Ref() *C.lgI2cMsg_t {
	if x == nil {
		return nil
	}
	return x.ref6927ca3d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LgI2cMsg) Free() {
	if x != nil && x.allocs6927ca3d != nil {
		x.allocs6927ca3d.(*cgoAllocMap).Free()
		x.ref6927ca3d = nil
	}
}

// NewLgI2cMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLgI2cMsgRef(ref unsafe.Pointer) *LgI2cMsg {
	if ref == nil {
		return nil
	}
	obj := new(LgI2cMsg)
	obj.ref6927ca3d = (*C.lgI2cMsg_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LgI2cMsg) PassRef() (*C.lgI2cMsg_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6927ca3d != nil {
		return x.ref6927ca3d, nil
	}
	mem6927ca3d := allocLgI2cMsgMemory(1)
	ref6927ca3d := (*C.lgI2cMsg_t)(mem6927ca3d)
	allocs6927ca3d := new(cgoAllocMap)
	allocs6927ca3d.Add(mem6927ca3d)

	var caddr_allocs *cgoAllocMap
	ref6927ca3d.addr, caddr_allocs = (C.uint16_t)(x.Addr), cgoAllocsUnknown
	allocs6927ca3d.Borrow(caddr_allocs)

	var cflags_allocs *cgoAllocMap
	ref6927ca3d.flags, cflags_allocs = (C.uint16_t)(x.Flags), cgoAllocsUnknown
	allocs6927ca3d.Borrow(cflags_allocs)

	var clen_allocs *cgoAllocMap
	ref6927ca3d.len, clen_allocs = (C.uint16_t)(x.Len), cgoAllocsUnknown
	allocs6927ca3d.Borrow(clen_allocs)

	var cbuf_allocs *cgoAllocMap
	ref6927ca3d.buf, cbuf_allocs = copyPUint8Bytes((*sliceHeader)(unsafe.Pointer(&x.Buf)))
	allocs6927ca3d.Borrow(cbuf_allocs)

	x.ref6927ca3d = ref6927ca3d
	x.allocs6927ca3d = allocs6927ca3d
	return ref6927ca3d, allocs6927ca3d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LgI2cMsg) PassValue() (C.lgI2cMsg_t, *cgoAllocMap) {
	if x.ref6927ca3d != nil {
		return *x.ref6927ca3d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LgI2cMsg) Deref() {
	if x.ref6927ca3d == nil {
		return
	}
	x.Addr = (uint16)(x.ref6927ca3d.addr)
	x.Flags = (uint16)(x.ref6927ca3d.flags)
	x.Len = (uint16)(x.ref6927ca3d.len)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Buf))
	hxfc4425b.Data = unsafe.Pointer(x.ref6927ca3d.buf)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ? x.Buf x.ref6927ca3d.buf

}

func (x LgThreadFunc) PassRef() (ref *C.lgThreadFunc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if lgThreadFunc4599736FFunc == nil {
		lgThreadFunc4599736FFunc = x
	}
	return (*C.lgThreadFunc_t)(C.lgThreadFunc_t_4599736f), nil
}

func NewLgThreadFuncRef(ref unsafe.Pointer) *LgThreadFunc {
	return (*LgThreadFunc)(ref)
}

//export lgThreadFunc4599736F
func lgThreadFunc4599736F(carg0 unsafe.Pointer) unsafe.Pointer {
	if lgThreadFunc4599736FFunc != nil {
		arg04599736f := (unsafe.Pointer)(unsafe.Pointer(carg0))
		ret4599736f := lgThreadFunc4599736FFunc(arg04599736f)
		ret, _ := ret4599736f, cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var lgThreadFunc4599736FFunc LgThreadFunc

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// allocStruct_lgPulseMemory allocates memory for type C.struct_lgPulse_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_lgPulseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_lgPulseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct_lgPulseValue = unsafe.Sizeof([1]C.struct_lgPulse_s{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSLgPulse transforms a sliced Go data structure into plain C format.
func unpackArgSLgPulse(x []LgPulse) (unpacked *C.struct_lgPulse_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_lgPulseMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_lgPulse_s)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_lgPulse_s)(h.Data)
	return
}

// packSLgPulse reads sliced Go data structure out from plain C format.
func packSLgPulse(v []LgPulse, ptr0 *C.struct_lgPulse_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_lgPulseValue]C.struct_lgPulse_s)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLgPulseRef(unsafe.Pointer(&ptr1))
	}
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// unpackArgSLgI2cMsg transforms a sliced Go data structure into plain C format.
func unpackArgSLgI2cMsg(x []LgI2cMsg) (unpacked *C.lgI2cMsg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocLgI2cMsgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.lgI2cMsg_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.lgI2cMsg_t)(h.Data)
	return
}

// packSLgI2cMsg reads sliced Go data structure out from plain C format.
func packSLgI2cMsg(v []LgI2cMsg, ptr0 *C.lgI2cMsg_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLgI2cMsgValue]C.lgI2cMsg_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLgI2cMsgRef(unsafe.Pointer(&ptr1))
	}
}
